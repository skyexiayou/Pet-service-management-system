# 注册客户 - 订单与支付管理接口文档

## 一、项目概述

本文档描述了宠物服务管理系统第四阶段的开发成果：注册客户的订单与支付管理功能。系统支持订单全流程管理（生成、支付、查询），包括关联预约的订单和纯用品购买订单，实现了完整的支付流程和库存管理。

## 二、技术栈

- **框架**: Spring Boot 3.1.2
- **ORM**: MyBatis-Plus 3.5.3.2
- **数据库**: MySQL 8.0
- **JDK**: 17
- **API文档**: Knife4j 4.4.0
- **验证框架**: Jakarta Bean Validation

## 三、核心功能

### 3.1 订单管理

#### 3.1.1 生成关联预约的订单

**接口路径**：`POST /api/orders/appointment`

**功能说明**：根据已有预约生成订单，订单金额包含预约的服务费用（美容+寄养+医疗）和可选的用品费用

**请求体示例**：
```json
{
  "apptId": 1,
  "products": [
    {
      "relId": 1,
      "quantity": 2
    }
  ]
}
```

**响应示例**：
```json
{
  "code": 200,
  "message": "操作成功",
  "data": 1
}
```

**业务规则**：
1. 预约状态必须为"待服务"
2. 订单总金额 = 美容服务费用 + 寄养费用 + 医疗费用 + 用品费用
3. 所有金额计算使用BigDecimal，保留2位小数
4. 订单创建成功后，状态默认为"未支付"
5. 所有操作在单个事务中执行，确保原子性

#### 3.1.2 生成纯用品购买订单

**接口路径**：`POST /api/orders/products`

**功能说明**：不关联预约，直接购买宠物用品

**请求体示例**：
```json
{
  "userId": 1,
  "storeId": 1,
  "products": [
    {
      "relId": 1,
      "quantity": 2
    },
    {
      "relId": 2,
      "quantity": 1
    }
  ]
}
```

**响应示例**：
```json
{
  "code": 200,
  "message": "操作成功",
  "data": 2
}
```

**业务规则**：
1. 验证库存充足（StoreStock >= Quantity）
2. 库存不足时返回错误信息，包含当前库存数量
3. 订单创建成功后自动扣减库存
4. 使用数据库行锁防止并发库存问题
5. 订单总金额 = 所有用品小计之和
6. 所有操作在单个事务中执行，失败时自动回滚

**错误示例**：
```json
{
  "code": 400,
  "message": "该门店该用品库存不足，当前库存：5",
  "data": null
}
```

#### 3.1.3 查询用户的订单列表

**接口路径**：`GET /api/orders/user/{userId}`

**功能说明**：查询指定用户的所有订单记录

**响应示例**：
```json
{
  "code": 200,
  "message": "操作成功",
  "data": [
    {
      "orderId": 1,
      "apptId": 1,
      "totalAmount": 500.00,
      "payStatus": "已支付",
      "payMethod": "WECHAT",
      "payTime": "2025-12-18 14:30:00",
      "orderCreateTime": "2025-12-18 14:00:00"
    },
    {
      "orderId": 2,
      "apptId": null,
      "totalAmount": 360.00,
      "payStatus": "未支付",
      "payMethod": null,
      "payTime": null,
      "orderCreateTime": "2025-12-18 15:00:00"
    }
  ]
}
```

#### 3.1.4 查询订单详情

**接口路径**：`GET /api/orders/{orderId}`

**功能说明**：查询订单的详细信息，包含服务明细和用品明细

**响应示例**：
```json
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "orderId": 1,
    "apptId": 1,
    "totalAmount": 500.00,
    "payStatus": "已支付",
    "payMethod": "WECHAT",
    "payTime": "2025-12-18 14:30:00",
    "orderCreateTime": "2025-12-18 14:00:00",
    "beautyServices": [
      {
        "beautyId": 1,
        "beautyName": "全身清洁",
        "beautyType": "美容",
        "price": 80.00,
        "duration": 60,
        "beautyRemarks": "包含洗澡、吹干、梳理毛发"
      }
    ],
    "fosterService": {
      "fosterId": 1,
      "startDate": "2025-12-25",
      "endDate": "2025-12-30",
      "fosterFee": 500.00,
      "fosterStatus": "进行中",
      "fosterRemarks": "每日喂食2次",
      "dailyStatus": null
    },
    "medicalService": {
      "medicalId": 1,
      "medicalTime": "2025-12-25 10:00:00",
      "diagnosis": "待诊断：咳嗽、精神差",
      "medication": null,
      "medicalFee": 0.00,
      "followUpAdvice": null
    },
    "products": [
      {
        "productName": "狗粮",
        "productType": "食品",
        "quantity": 2,
        "actualPrice": 180.00,
        "subtotal": 360.00
      }
    ]
  }
}
```

### 3.2 支付管理

#### 3.2.1 在线支付

**接口路径**：`PUT /api/orders/{orderId}/pay`

**功能说明**：对订单进行在线支付

**请求体示例**：
```json
{
  "payMethod": "WECHAT"
}
```

**响应示例**：
```json
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "paymentVoucher": "PAY_202512180001",
    "payTime": "2025-12-18 14:30:00",
    "payMethod": "WECHAT",
    "totalAmount": 500.00
  }
}
```

**业务规则**：
1. 订单状态必须为"未支付"
2. 支付方式支持：WECHAT（微信）、ALIPAY（支付宝）、CASH（现金）
3. 支付成功后生成唯一支付凭证号（格式：PAY_YYYYMMDDXXXX）
4. 更新订单状态为"已支付"
5. 记录支付时间和支付方式
6. 所有操作在单个事务中执行

**错误示例**：
```json
{
  "code": 400,
  "message": "订单状态不是'未支付'，无法支付",
  "data": null
}
```

## 四、数据一致性保证

### 4.1 金额计算

系统使用BigDecimal进行所有金额计算，保留2位小数，避免浮点数精度问题。

**金额计算规则**：
- 用品小计 = 数量 × 单价
- 订单总金额 = 美容费用 + 寄养费用 + 医疗费用 + 用品费用总和
- 所有金额在后端计算，前端仅展示

### 4.2 事务控制

所有涉及多表操作的接口都使用@Transactional注解保证原子性：
- 订单生成：Order表 + OrderProduct表 + 库存扣减
- 支付操作：Order表状态更新
- 任何步骤失败都会回滚所有数据库更改

### 4.3 库存管理

纯用品购买订单的库存管理：
1. 使用SELECT ... FOR UPDATE行锁查询库存
2. 验证库存充足
3. 创建订单记录
4. 扣减库存（UPDATE ... WHERE StoreStock >= Quantity）
5. 事务提交或回滚

### 4.4 支付凭证生成

支付凭证号格式：PAY_YYYYMMDDXXXX
- YYYYMMDD：支付日期
- XXXX：4位序列号（0001-9999循环）
- 使用AtomicInteger保证线程安全

## 五、错误码说明

| 错误码 | 错误信息 | 说明 |
|--------|----------|------|
| 200 | 操作成功 | 请求成功 |
| 400 | 预约不存在 | 预约ID无效 |
| 400 | 预约状态不是'待服务'，无法生成订单 | 预约状态校验失败 |
| 400 | 用品不存在 | 用品关联ID无效 |
| 400 | 该门店该用品库存不足，当前库存：XXX | 库存不足 |
| 400 | 库存扣减失败，可能库存不足 | 并发库存扣减失败 |
| 400 | 订单不存在 | 订单ID无效 |
| 400 | 订单状态不是'未支付'，无法支付 | 支付状态校验失败 |
| 500 | 系统错误 | 服务器内部错误 |

## 六、测试步骤

### 6.1 环境准备

1. 确保MySQL数据库已安装并启动
2. 确保数据库中已有测试数据：
   - 至少1个用户（user表）
   - 至少1个宠物（pet表）
   - 至少1个门店（store表）
   - 至少1个预约（appointment表，状态为"待服务"）
   - 至少1个美容项目（beauty表）
   - 至少1个用品（petProduct表和petProductStore表，有库存）
3. 启动项目：`mvn spring-boot:run`
4. 访问API文档：http://localhost:8081/doc.html

### 6.2 测试场景

#### 场景1：生成关联预约的订单（仅服务费用）

1. 打开Knife4j文档界面
2. 找到"订单管理"分组下的"生成关联预约的订单"接口
3. 填写请求参数：
```json
{
  "apptId": 1
}
```
4. 点击"执行"，查看响应
5. 预期结果：返回订单ID，code=200
6. 验证：查询订单详情，确认总金额等于服务费用总和

#### 场景2：生成关联预约的订单（服务+用品）

1. 填写请求参数：
```json
{
  "apptId": 1,
  "products": [
    {
      "relId": 1,
      "quantity": 2
    }
  ]
}
```
2. 点击"执行"
3. 预期结果：返回订单ID，code=200
4. 验证：查询订单详情，确认总金额 = 服务费用 + 用品费用

#### 场景3：生成纯用品购买订单

1. 找到"生成纯用品购买订单"接口
2. 填写请求参数：
```json
{
  "userId": 1,
  "storeId": 1,
  "products": [
    {
      "relId": 1,
      "quantity": 2
    },
    {
      "relId": 2,
      "quantity": 1
    }
  ]
}
```
3. 点击"执行"
4. 预期结果：返回订单ID，code=200
5. 验证：查询数据库，确认库存已扣减

#### 场景4：库存不足测试

1. 查询某个用品的当前库存（假设为5）
2. 尝试购买数量为10的该用品
3. 预期结果：返回错误信息"该门店该用品库存不足，当前库存：5"

#### 场景5：查询订单列表

1. 找到"查询用户的订单列表"接口
2. 输入userId=1
3. 点击"执行"
4. 预期结果：返回该用户所有订单记录

#### 场景6：查询订单详情

1. 找到"查询订单详情"接口
2. 输入orderId（使用场景2创建的订单ID）
3. 点击"执行"
4. 预期结果：返回完整的订单信息，包含服务明细和用品明细

#### 场景7：在线支付（成功）

1. 找到"在线支付"接口
2. 输入orderId（使用场景3创建的订单ID）
3. 填写请求参数：
```json
{
  "payMethod": "WECHAT"
}
```
4. 点击"执行"
5. 预期结果：返回支付凭证号，格式为PAY_YYYYMMDDXXXX
6. 验证：查询订单详情，状态变为"已支付"

#### 场景8：重复支付测试

1. 尝试对已支付的订单再次支付
2. 预期结果：返回错误信息"订单状态不是'未支付'，无法支付"

#### 场景9：支付方式测试

1. 创建3个订单
2. 分别使用WECHAT、ALIPAY、CASH支付
3. 预期结果：所有支付成功，订单记录中payMethod字段正确

#### 场景10：金额精度测试

1. 创建订单，包含多个用品，单价为小数（如180.50）
2. 查询订单详情
3. 验证：所有金额字段保留2位小数，计算准确

### 6.3 异常场景测试

#### 测试1：预约状态无效

1. 尝试为状态不是"待服务"的预约生成订单
2. 预期结果：返回"预约状态不是'待服务'，无法生成订单"

#### 测试2：用品不存在

1. 使用不存在的relId生成订单
2. 预期结果：返回"用品不存在"

#### 测试3：订单不存在

1. 查询不存在的订单ID
2. 预期结果：返回"订单不存在"

#### 测试4：支付方式无效

1. 尝试使用无效的支付方式（如"INVALID"）
2. 预期结果：返回参数校验错误

#### 测试5：并发库存扣减

1. 使用多线程同时购买同一用品
2. 预期结果：库存扣减正确，不会出现超卖

## 七、注意事项

1. **金额精度**：所有金额使用BigDecimal类型，保留2位小数
2. **事务回滚**：订单创建或支付过程中任何步骤失败，所有数据库更改都会回滚
3. **库存管理**：使用行锁防止并发问题，确保库存数据准确
4. **支付凭证**：支付凭证号全局唯一，可用于后续对账
5. **数据权限**：用户只能查询和操作自己的订单
6. **时间格式**：所有时间字段使用ISO 8601格式，时区为GMT+8
7. **后端计算**：所有金额在后端计算，前端不应修改金额

## 八、常见问题

### Q1：为什么订单生成失败？
A：请检查以下几点：
- 预约状态是否为"待服务"
- 用品库存是否充足
- 用品关联ID是否有效

### Q2：为什么无法支付订单？
A：支付订单需要满足条件：
- 订单状态必须是"未支付"
- 支付方式必须为WECHAT、ALIPAY或CASH之一

### Q3：如何查看订单包含哪些服务和用品？
A：调用"查询订单详情"接口，响应中会包含beautyServices、fosterService、medicalService和products四个字段，分别对应服务和用品明细。

### Q4：订单总金额如何计算？
A：订单总金额 = 美容服务费用 + 寄养费用 + 医疗费用 + 用品费用总和，所有计算使用BigDecimal保留2位小数。

### Q5：支付凭证号的格式是什么？
A：支付凭证号格式为PAY_YYYYMMDDXXXX，其中YYYYMMDD为支付日期，XXXX为4位序列号。

### Q6：库存不足时会发生什么？
A：系统会拒绝订单创建，并返回错误信息，包含当前库存数量。已执行的数据库操作会自动回滚。

### Q7：纯用品购买订单和关联预约订单有什么区别？
A：
- 关联预约订单：apptId不为空，包含服务费用和可选的用品费用
- 纯用品购买订单：apptId为空，仅包含用品费用，需要扣减库存

## 九、联系方式

如有问题或建议，请联系项目开发团队。

---

**文档版本**：v1.0  
**更新时间**：2025-12-18  
**编写人**：Kiro AI Assistant
